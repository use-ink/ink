<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Defines the interface for a chain extension."><title>chain_extension in ink - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ink" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://use.ink/crate-docs/favicon.png"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../ink/index.html"><img src="https://use.ink/img/crate-docs/logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../ink/index.html"><img src="https://use.ink/img/crate-docs/logo.png" alt="logo"></a><h2><a href="../ink/index.html">ink</a><span class="version">6.0.0-alpha</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">chain_<wbr>extension</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#structure" title="Structure">Structure</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#macro-attributes" title="Macro Attributes">Macro Attributes</a></li><li><a href="#method-attributes" title="Method Attributes">Method Attributes</a><ul><li><a href="#details-handle_status" title="Details: `handle_status`">Details: <code>handle_status</code></a></li><li><a href="#usage-handle_status" title="Usage: `handle_status`">Usage: <code>handle_status</code></a></li></ul></li><li><a href="#combinations" title="Combinations">Combinations</a></li><li><a href="#error-code" title="Error Code">Error Code</a></li><li><a href="#example-definition" title="Example: Definition">Example: Definition</a></li><li><a href="#example-environment" title="Example: Environment">Example: Environment</a></li><li><a href="#example-usage" title="Example: Usage">Example: Usage</a></li><li><a href="#technical-limitations" title="Technical Limitations">Technical Limitations</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate ink</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ink</a></div><h1>Attribute Macro <span class="attr">chain_extension</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>#[chain_extension]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Defines the interface for a chain extension.</p>
<h2 id="structure"><a class="doc-anchor" href="#structure">§</a>Structure</h2>
<p>The interface consists of an error code that indicates lightweight errors
as well as the definition of some chain extension methods.</p>
<p>The overall structure follows that of a simple Rust trait definition.
The error code is defined as an associated type definition of the trait definition.
The methods are defined as associated trait methods without implementation.</p>
<p>Chain extension methods must not have a <code>self</code> receiver such as <code>&amp;self</code> or <code>&amp;mut self</code>
and must have inputs and output that implement the SCALE encoding and decoding.
Their return value follows specific rules that can be altered using the
<code>handle_status</code> attribute which is described in more detail below.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>Usually the chain extension definition using this procedural macro is provided
by the author of the chain extension in a separate crate.
ink! smart contracts using this chain extension simply depend on this crate
and use its associated environment definition in order to make use of
the methods provided by the chain extension.</p>
<h2 id="macro-attributes"><a class="doc-anchor" href="#macro-attributes">§</a>Macro Attributes</h2>
<p>The macro supports only one required argument:</p>
<ul>
<li>
<p><code>extension = N: u16</code>:</p>
<p>The runtime may have several chain extensions at the same time. The <code>extension</code>
identifier points to the corresponding chain extension in the runtime.
The value should be the same as during the definition of the chain extension.</p>
</li>
</ul>
<h2 id="method-attributes"><a class="doc-anchor" href="#method-attributes">§</a>Method Attributes</h2>
<p>There are three different attributes with which the chain extension methods
can be flagged:</p>
<div><table><thead><tr><th style="text-align: left">Attribute</th><th style="text-align: center">Required</th><th style="text-align: left">Default Value</th><th style="text-align: center">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ink(function = N: u16)</code></td><td style="text-align: center">Yes</td><td style="text-align: left">-</td><td style="text-align: center">Determines the unique function ID within the</td></tr>
<tr><td style="text-align: left">chain extension.</td><td style="text-align: center"></td><td style="text-align: left"><code>ink(handle_status = flag: bool)</code></td><td style="text-align: center">Optional</td></tr>
<tr><td style="text-align: left">that the returned status code of the chain extension method always indicates success</td><td style="text-align: center"></td><td style="text-align: left"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left">and therefore always loads and decodes the output buffer of the call.</td><td style="text-align: center"></td><td style="text-align: left"></td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<p>As with all ink! attributes multiple of them can either appear in a contiguous list:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[ink(function = <span class="number">5</span>, handle_status = <span class="bool-val">false</span>)]
</span><span class="kw">fn </span>key_access_for_account(key: <span class="kw-2">&amp;</span>[u8], account: <span class="kw-2">&amp;</span>[u8]) -&gt; Access;</code></pre></div>
<p>…or as multiple stand alone ink! attributes applied to the same item:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[ink(function = <span class="number">5</span>)]
#[ink(handle_status = <span class="bool-val">false</span>)]
</span><span class="kw">fn </span>key_access_for_account(key: <span class="kw-2">&amp;</span>[u8], account: <span class="kw-2">&amp;</span>[u8]) -&gt; Access;</code></pre></div>
<h3 id="details-handle_status"><a class="doc-anchor" href="#details-handle_status">§</a>Details: <code>handle_status</code></h3>
<p>Default value: <code>true</code></p>
<p>By default all chain extension methods should return a <code>Result&lt;T, E&gt;</code> where <code>E: From&lt;Self::ErrorCode&gt;</code>. The <code>Self::ErrorCode</code> represents the error code of the chain
extension. This means that a smart contract calling such a chain extension method
first queries the returned status code of the chain extension method and only loads
and decodes the output if the returned status code indicates a successful call.
This design was chosen as it is more efficient when no output besides the error
code is required for a chain extension call. When designing a chain extension try to
utilize the error code to return errors and only use the output buffer for information
that does not fit in a single <code>u32</code> value.</p>
<p>A chain extension method that is flagged with <code>handle_status = false</code> assumes that the
returned error code will always indicate success. Therefore it will always load and
decode the output buffer and loses the <code>E: From&lt;Self::ErrorCode&gt;</code> constraint for the
call.</p>
<p>Note that if a chain extension method does not return <code>Result&lt;T, E&gt;</code> where <code>E: From&lt;Self::ErrorCode&gt;</code> but <code>handle_status = true</code> it will still return a value of type
<code>Result&lt;T, Self::ErrorCode&gt;</code>.</p>
<h3 id="usage-handle_status"><a class="doc-anchor" href="#usage-handle_status">§</a>Usage: <code>handle_status</code></h3>
<p>Use both <code>handle_status = false</code> and non-<code>Result&lt;T, E&gt;</code> return type for the same chain
extension method if a call to it may never fail and never returns a <code>Result</code> type.</p>
<h2 id="combinations"><a class="doc-anchor" href="#combinations">§</a>Combinations</h2>
<p>Due to the possibility to flag a chain extension method with <code>handle_status</code> and
return or not <code>Result&lt;T, E&gt;</code> there are 4 different cases with slightly varying
semantics:</p>
<div><table><thead><tr><th style="text-align: center"><code>handle_status</code></th><th style="text-align: center">Returns <code>Result&lt;T, E&gt;</code></th><th style="text-align: left">Effects</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: left">The chain extension method is required to return a value of type</td></tr>
<tr><td style="text-align: center"><code>Result&lt;T, E&gt;</code> where <code>E: From&lt;Self::ErrorCode&gt;</code>. A call will always check if the</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">returned status code indicates success and only then will load and decode the value in</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">the output buffer.</td><td style="text-align: center"></td><td style="text-align: left"><code>true</code></td></tr>
<tr><td style="text-align: center">non-<code>Result</code> type. A call will always check if the returned status code indicates</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">success and only then will load and decode the value in the output buffer. The actual</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">return type of the chain extension method is still <code>Result&lt;T, Self::ErrorCode&gt;</code> when</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">the chain extension method was defined to return a value of type <code>T</code>.</td><td style="text-align: center"></td><td style="text-align: left"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center">The chain extension method is required to return a value of type `Result&lt;T,</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">E&gt;`. A call will always assume that the returned status code indicates success and</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">therefore always load and decode the output buffer directly.</td><td style="text-align: center"></td><td style="text-align: left"><code>false</code></td></tr>
<tr><td style="text-align: center">The chain extension method may return any non-<code>Result</code> type. A call will always assume</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">that the returned status code indicates success and therefore always load and decode</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center">the output buffer directly.</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><h2 id="error-code"><a class="doc-anchor" href="#error-code">§</a>Error Code</h2>
<p>Every chain extension defines exactly one <code>ErrorCode</code> using the following syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[ink::chain_extension(extension = <span class="number">0</span>)]
</span><span class="kw">pub trait </span>MyChainExtension {
    <span class="kw">type </span>ErrorCode = MyErrorCode;

    <span class="comment">// more definitions
</span>}</code></pre></div>
<p>The defined <code>ErrorCode</code> must implement <code>FromStatusCode</code> which should be implemented as
a more or less trivial conversion from the <code>u32</code> status code to a <code>Result&lt;(), Self::ErrorCode&gt;</code>. The <code>Ok(())</code> value indicates that the call to the chain extension
method was successful.</p>
<p>By convention an error code of <code>0</code> represents success.
However, chain extension authors may use whatever suits their needs.</p>
<h2 id="example-definition"><a class="doc-anchor" href="#example-definition">§</a>Example: Definition</h2>
<p>In the below example a chain extension is defined that allows its users to read and
write from and to the runtime storage using access privileges:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Custom chain extension to read to and write from the runtime.
</span><span class="attr">#[ink::chain_extension(extension = <span class="number">0</span>)]
</span><span class="kw">pub trait </span>RuntimeReadWrite {
    <span class="kw">type </span>ErrorCode = ReadWriteErrorCode;

    <span class="doccomment">/// Reads from runtime storage.
    ///
    /// # Note
    ///
    /// Actually returns a value of type `Result&lt;Vec&lt;u8&gt;, Self::ErrorCode&gt;`.
    </span><span class="attr">#[ink(function = <span class="number">1</span>)]
    </span><span class="kw">fn </span>read(key: <span class="kw-2">&amp;</span>[u8]) -&gt; Vec&lt;u8&gt;;

    <span class="doccomment">/// Reads from runtime storage.
    ///
    /// Returns the number of bytes read and up to 32 bytes of the
    /// read value. Unused bytes in the output are set to 0.
    ///
    /// # Errors
    ///
    /// If the runtime storage cell stores a value that requires more than
    /// 32 bytes.
    ///
    /// # Note
    ///
    /// This requires `ReadWriteError` to implement `From&lt;ReadWriteErrorCode&gt;`
    /// and may potentially return any `Self::ErrorCode` through its return value.
    </span><span class="attr">#[ink(function = <span class="number">2</span>)]
    </span><span class="kw">fn </span>read_small(key: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(u32, [u8; <span class="number">32</span>]), ReadWriteError&gt;;

    <span class="doccomment">/// Writes into runtime storage.
    ///
    /// # Note
    ///
    /// Actually returns a value of type `Result&lt;(), Self::ErrorCode&gt;`.
    </span><span class="attr">#[ink(function = <span class="number">3</span>)]
    </span><span class="kw">fn </span>write(key: <span class="kw-2">&amp;</span>[u8], value: <span class="kw-2">&amp;</span>[u8]);

    <span class="doccomment">/// Returns the access allowed for the key for the caller.
    ///
    /// # Note
    ///
    /// Assumes to never fail the call and therefore always returns `Option&lt;Access&gt;`.
    </span><span class="attr">#[ink(function = <span class="number">4</span>, handle_status = <span class="bool-val">false</span>)]
    </span><span class="kw">fn </span>access(key: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Option</span>&lt;Access&gt;;

    <span class="doccomment">/// Unlocks previously acquired permission to access key.
    ///
    /// # Errors
    ///
    /// If the permission was not granted.
    ///
    /// # Note
    ///
    /// Assumes the call to never fail and therefore does _NOT_ require `UnlockAccessError`
    /// to implement `From&lt;Self::ErrorCode&gt;` as in the `read_small` method above.
    </span><span class="attr">#[ink(function = <span class="number">5</span>, handle_status = <span class="bool-val">false</span>)]
    </span><span class="kw">fn </span>unlock_access(key: <span class="kw-2">&amp;</span>[u8], access: Access) -&gt; <span class="prelude-ty">Result</span>&lt;(), UnlockAccessError&gt;;
}</code></pre></div>
<p>All the error types and other utility types used in the chain extension definition
above are often required to implement various traits such as SCALE’s <code>Encode</code> and
<code>Decode</code> as well as <code>scale-info</code>’s <code>TypeInfo</code> trait.</p>
<p>A full example of the above chain extension definition can be seen
<a href="https://github.com/use-ink/ink/blob/017f71d60799b764425334f86b732cc7b7065fe6/crates/lang/macro/tests/ui/chain_extension/simple.rs">here</a>.</p>
<h2 id="example-environment"><a class="doc-anchor" href="#example-environment">§</a>Example: Environment</h2>
<p>In order to allow ink! smart contracts to use the above defined chain extension it
needs to be integrated into an <code>Environment</code> definition as shown below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ink_env::{
    DefaultEnvironment,
    Environment,
};

<span class="attr">#[derive(Clone)]
</span><span class="kw">pub enum </span>CustomEnvironment {}

<span class="kw">impl </span>Environment <span class="kw">for </span>CustomEnvironment {
    <span class="kw">const </span>MAX_EVENT_TOPICS: usize =
        &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::MAX_EVENT_TOPICS;

    <span class="kw">type </span>AccountId = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::AccountId;
    <span class="kw">type </span>Balance = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::Balance;
    <span class="kw">type </span>Hash = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::Hash;
    <span class="kw">type </span>BlockNumber = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::BlockNumber;
    <span class="kw">type </span>Timestamp = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::Timestamp;
    <span class="kw">type </span>EventRecord = &lt;DefaultEnvironment <span class="kw">as </span>Environment&gt;::EventRecord;

    <span class="kw">type </span>ChainExtension = RuntimeReadWrite;
}</code></pre></div>
<p>Above we defined the <code>CustomEnvironment</code> which defaults to ink!’s <code>DefaultEnvironment</code>
for all constants and types but the <code>ChainExtension</code> type which is assigned to our
newly defined chain extension.</p>
<h2 id="example-usage"><a class="doc-anchor" href="#example-usage">§</a>Example: Usage</h2>
<p>An ink! smart contract can use the above defined chain extension through the
<code>Environment</code> definition defined in the last example section using the <code>env</code> macro
parameter as shown below.</p>
<p>Note that chain extension methods are accessible through <code>Self::extension()</code> or
<code>self.extension()</code>. For example as in <code>Self::extension().read(...)</code> or
<code>self.extension().read(...)</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[ink::contract(env = CustomEnvironment)]
</span><span class="kw">mod </span>read_writer {
    <span class="attr">#[ink(storage)]
    </span><span class="kw">pub struct </span>ReadWriter {}

    <span class="kw">impl </span>ReadWriter {
        <span class="attr">#[ink(constructor)]
        </span><span class="kw">pub fn </span>new() -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{} }

        <span class="attr">#[ink(message)]
        </span><span class="kw">pub fn </span>read(<span class="kw-2">&amp;</span><span class="self">self</span>, key: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, ReadWriteErrorCode&gt; {
            <span class="self">self</span>.env()
                .extension()
                .read(<span class="kw-2">&amp;</span>key)
        }

        <span class="attr">#[ink(message)]
        </span><span class="kw">pub fn </span>read_small(<span class="kw-2">&amp;</span><span class="self">self</span>, key: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(u32, [u8; <span class="number">32</span>]), ReadWriteError&gt; {
            <span class="self">self</span>.env()
                .extension()
                .read_small(<span class="kw-2">&amp;</span>key)
        }

        <span class="attr">#[ink(message)]
        </span><span class="kw">pub fn </span>write(
            <span class="kw-2">&amp;</span><span class="self">self</span>,
            key: Vec&lt;u8&gt;,
            value: Vec&lt;u8&gt;,
        ) -&gt; <span class="prelude-ty">Result</span>&lt;(), ReadWriteErrorCode&gt; {
            <span class="self">self</span>.env()
                .extension()
                .write(<span class="kw-2">&amp;</span>key, <span class="kw-2">&amp;</span>value)
        }

        <span class="attr">#[ink(message)]
        </span><span class="kw">pub fn </span>access(<span class="kw-2">&amp;</span><span class="self">self</span>, key: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Access&gt; {
            <span class="self">self</span>.env()
                .extension()
                .access(<span class="kw-2">&amp;</span>key)
        }

        <span class="attr">#[ink(message)]
        </span><span class="kw">pub fn </span>unlock_access(<span class="kw-2">&amp;</span><span class="self">self</span>, key: Vec&lt;u8&gt;, access: Access) -&gt; <span class="prelude-ty">Result</span>&lt;(), UnlockAccessError&gt; {
            <span class="self">self</span>.env()
                .extension()
                .unlock_access(<span class="kw-2">&amp;</span>key, access)
        }
    }
}</code></pre></div>
<h2 id="technical-limitations"><a class="doc-anchor" href="#technical-limitations">§</a>Technical Limitations</h2>
<ul>
<li>Due to technical limitations it is not possible to refer to the <code>ErrorCode</code>
associated type using <code>Self::ErrorCode</code> anywhere within the chain extension and its
defined methods. Instead chain extension authors should directly use the error code
type when required. This limitation might be lifted in future versions of ink!.</li>
<li>It is not possible to declare other chain extension traits as super traits or super
chain extensions of another.</li>
</ul>
</div></details></section></div></main></body></html>