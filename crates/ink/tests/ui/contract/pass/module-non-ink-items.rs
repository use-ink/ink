#![allow(unexpected_cfgs)]

#[ink::contract]
mod contract {
    #[ink(storage)]
    pub struct Contract {}

    impl Contract {
        #[ink(constructor)]
        pub fn constructor() -> Self {
            Self {}
        }

        #[ink(message)]
        pub fn message(&self) {}
    }

    #[allow(dead_code)]
    pub enum RustEnum {
        A,
        B,
    }
    #[allow(dead_code)]
    pub union RustUnion {
        pub field_a: i32,
        pub field_b: [u8; 4],
    }
    #[allow(dead_code)]
    pub struct RustStruct {
        pub a: i32,
        pub b: i32,
    }

    impl RustStruct {
        pub fn rust_method() {}
    }

    pub const RUST_CONST: bool = true;
    pub type RustAlias = RustStruct;
}

fn main() {
    // Use the Rust types defined in the ink! smart contract module
    // in order to assert that they are properly re-generated by ink!.
    let _ = contract::RustEnum::A;
    let _ = contract::RustUnion { field_a: 42 };
    let _ = contract::RustStruct { a: 0, b: 1 };
    let _ = contract::RustStruct::rust_method();
    let _ = contract::RUST_CONST;
    let _: contract::RustAlias = contract::RustStruct { a: 0, b: 1 };
}
