<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The default dynamic storage allocator."><meta name="keywords" content="rust, rustlang, rust-lang, alloc"><title>ink_storage::alloc - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../ink_storage/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module alloc</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"><a href="../index.html">ink_storage</a></p><div id="sidebar-vars" data-name="alloc" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">ink_storage</a>::<wbr><a class="mod" href="">alloc</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/ink_storage/alloc/mod.rs.html#15-135" title="goto source code">[src]</a></span></h1><div class="docblock"><p>The default dynamic storage allocator.</p>
<p>Allows to allocate storage cells in a dynamic fashion.
This is important if users want to combine types of varying storage
footprints. For example, dynamic allocations are required whenever
a user wants to use a storage collection (e.g. <code>storage::Vec</code>) in
another storage collection: <code>storage::Vec&lt;storage::Vec&lt;T&gt;&gt;</code></p>
<h1 id="simplification" class="section-header"><a href="#simplification">Simplification</a></h1>
<p>The contracts pallet is using 256-bit keys for identifying storage cells.
This implies a storage space of <code>2^256</code> cells which is big enough to say that
there are probably never going to happen collisions anywhere at any time
if keys are chosen randomly. Using the built-in crypto hashers on unique
input we can be sure that there are never going to be collisions in this
space of <code>2^256</code> cells.</p>
<p>This way we can reduce the problem of finding another region in our storage
that fits certain requirements (e.g. a minimum size) to the problem of
finding another uniform slot. Since we are on 32-bit WebAssembly we have
memory limitations that make it impractical to have more than <code>2^32</code> dynamic
allocated entities, so we can create another limitation for having a total of
<code>2^32</code> dynamic allocations at any point in time.
This enables us to have 32-bit keys instead of 256-bit keys.</p>
<p>We can convert such 32-bit keys (represented by e.g. a <code>u32</code>) into 256-bit
keys by using one of the built-in crypto hashes that has a 256-bit output,
e.g. KECCAK, SHA-2 or BLAKE-2. For technical reasons we should prepend the
bytes of the 32-bit key by some unique byte sequence, e.g.:</p>
<pre><code class="language-no_compile">let key256 = blake2x256(b&quot;DYNAMICALLY ALLOCATED&quot;, bytes(key32));
</code></pre>
<h1 id="internals" class="section-header"><a href="#internals">Internals</a></h1>
<p>As described in [# Simplification] there are <code>2^32</code> possible uniform dynamic
allocations available. For each such slot the dynamic allocator stores via
a single bit in a bitvector if that slot is free or occupied.
This bitvector is called the <code>free</code> list.
However, searching in this <code>free</code> list for a 0 bit and thus a free slot
for a dynamic allocation would mean that for every 256 consecutively
occupied dynamic allocations there was a contract storage lookup required.
This might seem a lot but given that there could be thousands or
tens of thousands of dynamic allocations at any given time this might not scale
well.
For the reason of improving scalability we added another vector: the
so-called <code>set_bits</code> vector.
In this vector every <code>u8</code> element densely stores the number of set bits
(bits that are <code>1</code> or <code>true</code>) for each 256-bit package in the <code>free</code> list.
(Note that the <code>free</code> list is organized in 256-bit chunks of bits.)</p>
<p>This way, to search for an unoccupied dynamic allocation we iterate over
the set-bits vector which is 32 times more dense than our <code>free</code> list.
The additional density implies that we can query up to 8192 potential
dynamic storage allocations with a single contract storage look-up.</p>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Box.html" title="ink_storage::alloc::Box struct">Box</a></td><td class="docblock-short"><p>A dynamically allocated storage entity.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DynamicAllocation.html" title="ink_storage::alloc::DynamicAllocation struct">DynamicAllocation</a></td><td class="docblock-short"><p>A unique dynamic allocation.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.ContractPhase.html" title="ink_storage::alloc::ContractPhase enum">ContractPhase</a></td><td class="docblock-short"><p>The phase in which a contract execution can be.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.alloc.html" title="ink_storage::alloc::alloc fn">alloc</a></td><td class="docblock-short"><p>Returns a new dynamic storage allocation.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.finalize.html" title="ink_storage::alloc::finalize fn">finalize</a></td><td class="docblock-short"><p>Finalizes the global dynamic storage allocator instance.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.free.html" title="ink_storage::alloc::free fn">free</a></td><td class="docblock-short"><p>Frees the given dynamic storage allocation.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.initialize.html" title="ink_storage::alloc::initialize fn">initialize</a></td><td class="docblock-short"><p>Tells the global dynamic storage allocator instance how it shall initialize.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="ink_storage" data-search-js="../../search-index.js"></div>
    <script src="../../main.js"></script></body></html>